/*
  ==============================================================================

    TT_PatchConstructor.cpp
    Created: 2 Apr 2024 11:30:07am
    Author:  Matt Twitchen

  ==============================================================================
*/

#include "TT_PatchConstructor.h"

TT_PatchConstructor::TT_PatchConstructor()
{
    
}

TT_PatchConstructor::~TT_PatchConstructor()
{
}

void TT_PatchConstructor::setMode(int newMode)
{
    mode = (Mode)(newMode - 1); // correct offset from combo box
}

juce::XmlElement TT_PatchConstructor::constructPatch(std::vector<float> spectralParams, std::vector<float> temporalParams)
{
    juce::File init (juce::File::getSpecialLocation(juce::File::SpecialLocationType::userDesktopDirectory).getFullPathName() + "/ToneTrainer/Init.xml");
    
    jassert(init.existsAsFile());
    
    auto patch = juce::XmlDocument::parse(init);
    
    jassert(patch != nullptr);
    
    // !!!!! make sure it has write permissions !!!!!
    
    for(auto* node : patch->getChildIterator())
    {
        juce::String nodeName = node->getTagName();
        if(nodeName == "metadata")
        {
            setMetadata(node);
        } else if(nodeName == "parameter_data" )
        {
            switch(mode)
            {
                case SPECTRAL:
                    constructSpectralParameters(node);
                break;
                case TEMPORAL:
                    constructTemporalParameters(node);
                case BOTH:
                    constructSpectralParameters(node);
                    constructTemporalParameters(node);
                break;
            }
        }
    }
  
    return *patch;
}

void TT_PatchConstructor::setMetadata(juce::XmlElement* metadata)
{
    std::vector<juce::String> spectralNames;
    std::vector<juce::String> temporalNames;
    
    if(spectralTag == "Bright")
        spectralNames = PatchNames::bright;
    else if(spectralTag == "Dark")
        spectralNames = PatchNames::dark;
    else if(spectralTag == "Resonant")
        spectralNames = PatchNames::resonant;
    else if(spectralTag == "Soft")
        spectralNames = PatchNames::soft;
    
    if(temporalTag == "Pluck")
        temporalNames = PatchNames::pluck;
    else if(temporalTag == "Long Release")
        temporalNames = PatchNames::longRelease;
    else if(temporalTag == "Swell")
        temporalNames = PatchNames::swell;
    else if(temporalTag == "Short")
        temporalNames = PatchNames::soft;
    
    int spectralIndex = rand() % 40;
    int temporalIndex = rand() % 40;
    
    switch(mode)
    {
        case SPECTRAL:
            metadata->setAttribute("timbres", spectralTag);
            metadata->setAttribute("name", spectralNames[spectralIndex]);
            patchName = spectralNames[spectralIndex];
        break;
        case TEMPORAL:
            metadata->setAttribute("types", temporalTag);
            metadata->setAttribute("name", spectralNames[temporalIndex]);
            patchName = temporalNames[temporalIndex];
        break;
        case BOTH:
            metadata->setAttribute("timbres", spectralTag);
            metadata->setAttribute("types", temporalTag);
            metadata->setAttribute("name", spectralNames[spectralIndex] + " " + temporalNames[temporalIndex]);
            patchName = spectralNames[spectralIndex] + " " + temporalNames[temporalIndex];
        break;
        default:
            break;
    }
    
    metadata->setAttribute("author", "The Machines");
    metadata->setAttribute("collection", "ToneTrainer Patches");
    metadata->setAttribute("notes", "Patch generated by ToneTrainer");
}

void TT_PatchConstructor::constructSpectralParameters(juce::XmlElement* parameterNode)
{
    auto filterFrequency = parameterNode->getChildByAttribute("id", "FilterFrequency");
    filterFrequency->setAttribute("value", spectralParams[0]);
    
    auto filterEmphasis = parameterNode->getChildByAttribute("id", "FilterEmphasis");
    filterEmphasis->setAttribute("value", spectralParams[1]);
    
    if(mode == TEMPORAL) // precedence given to value from spectral tag
    {
        auto filterContour = parameterNode->getChildByAttribute("id", "FilterContour");
        filterContour->setAttribute("value", spectralParams[2]);
    }
    
    auto oscModMix = parameterNode->getChildByAttribute("id", "OscModMix");
    oscModMix->setAttribute("value", spectralParams[3]);
}

void TT_PatchConstructor::constructTemporalParameters(juce::XmlElement* parameterNode)
{
    auto filterAttack = parameterNode->getChildByAttribute("id", "FilterAttack");
    filterAttack->setAttribute("value", temporalParams[0]);
    
    auto filterDecay = parameterNode->getChildByAttribute("id", "FilterDecay");
    filterDecay->setAttribute("value", temporalParams[1]);
    
    auto filterSustain = parameterNode->getChildByAttribute("id", "FilterSustain");
    filterSustain->setAttribute("value", temporalParams[2]);
    
    auto filterRelease = parameterNode->getChildByAttribute("id", "FilterRelease");
    filterRelease->setAttribute("value", temporalParams[3]);
    
    auto vcaAttack = parameterNode->getChildByAttribute("id", "VcaAttack");
    vcaAttack->setAttribute("value", temporalParams[4]);
    
    auto vcaDecay = parameterNode->getChildByAttribute("id", "VcaDecay");
    vcaDecay->setAttribute("value", temporalParams[5]);
    
    auto vcaSustain = parameterNode->getChildByAttribute("id", "VcaSustain");
    vcaSustain->setAttribute("value", temporalParams[6]);
    
    auto vcaRelease = parameterNode->getChildByAttribute("id", "VcaRelease");
    vcaRelease->setAttribute("value", temporalParams[7]);
    
    auto filterContour = parameterNode->getChildByAttribute("id", "FilterContour");
    filterContour->setAttribute("value", temporalParams[8]);
}

void TT_PatchConstructor::savePatch(std::vector<float> spectralParams, std::vector<float> temporalParams)
{
    juce::XmlElement patchToSave = constructPatch(spectralParams, temporalParams);
    patchToSave.writeTo((juce::File::getSpecialLocation(juce::File::SpecialLocationType::userDesktopDirectory).getFullPathName())+ "/ToneTrainer/Generated Patches/" + patchName + ".xml");
}

void TT_PatchConstructor::reset()
{
    spectralParams.clear();
    temporalParams.clear();
}
